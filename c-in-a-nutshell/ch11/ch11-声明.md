# 声明 (Declaration)

声明决定了一个或多个标识符的意义与属性。（C11 引入的 `_Static_assert` 除外）
有几个不同种类的声明:

- 只声明结构，联合或枚举的标签，或枚举成员（枚举常量）
- 声明一个或多个对象或函数的标识符
- typedef 声明，它对已有类型声明新的名称
- `_Static_assert` 声明，它指示编译器不通过声明标识符的方式测试一个断言。

## 对象声明与函数声明

基本语法如下：

`[存储类型修饰符] 类型声明符[,声明符[,...]]`

### 示例

1. `enum { OFF,ON} toggle = ON;` 此声明定义了一个匿名的枚举类型，它只有枚举常量`OFF` 和 `ON`,以及该枚举类型的变量 `toggle`,该声明将`toggle`变量初始化为`ON`.
2. `struct CharColor{unsigned fg:4,bg:3,bl:1} attribute = {12,1,0};` 此声明定义了结构类型`struct CharColor`,它的成员是位字段`fg,bg,bl`,同时定义了该结构类型的变量 attribute,并将 attribute 初始化为 {12,1,0}.

### 存储类型修饰符

声明中出现的存储类型修饰符(storage class specifier) 用于修饰标识符的链接和对应对象的存储周期

> 链接(linkage) 和存储周期 (storage duration) 是 C 语言中常会遇到的困扰。链接（标识符属性）和存储周期（对象属性）两者在声明中都会受到相同关键字的影响
> 注意：对象具有存储周期，而非链接，标识符具有链接而非存储周期。

- `auto` 我们在函数中声明的变量默认的修饰符就是 `auto`, 也叫做动态存储期，因为其一般是分配在堆栈中的，而堆栈是随着函数调用的开始和结束而销毁的，因为这叫动态存储周期，
- `register` 当声明对象具有动态存储周期时，可以使用修饰符`register`。 该关键字可以为一个提示，告诉编译器所声明对象的访问应该尽量快，最好是将其分配在 CPU 寄存器(register)中.但是也仅仅是一个提示，不过，只要采用了 `register` 修饰符声明了对象，就不能用地址运算符对该对象进行操作。
- `static` 这个分两种情况。
  1.  被声明为 `static` 的函数标识符候有内部链接。也就是别的翻译单元无法使用所声明的函数标识符来访问该函数。
  2.  被声明为 `static` 的对象具有静态存储周期，其标识符可能为外部链接（声明在函数外），也可能为内部链接（声明在函数内）。
- `extern` 被声明为 `extern` 的函数和标识符和对象标识符具有外部链接。可以在程序中任何地址使用这些标识符。外部对象候有静态存储周期。
- `_Thread_local` 修饰符`_Thread_local` 声明对象为线程局部(thread-local),表示每个线程都分别具有该对象的实例。只有对象被声明为线程局部，而函数不能。如果在函数内部声明一个线程局部对象，声明必须具有修饰符 `extern` 或 `static`.

### 类型限定符

类型限定符有 `const`、`volatile`、`restrict` 和 `_Atomic`。
声明中可以使用多个限定符，没有顺序限制，甚至可以重复出现，只不少编译器会忽略重复值。

- `const` 对象类型如果采用了 `const` 限定符，则该对象就是常量。在定义对象之后程序无法修改它。
- `volatile` 对象可以被其他进程或事件修改，关键字 volatile 告诉编译器在每次使用该对象值时，都要重新读取它，即使程序本身自上一次获取后再没有修改过它的值，这种限定符通常用于硬件接口编程，以防止变量值被外部事件修改之后，未能及时更新。
- `restrict` 限定符 `restrict` 只适用于对象指针类型。这种类型限定符是 C99 新增加的，用来告诉编译器，一个被指针所引用的对象，如果它可以被修改，那么只能被 `restrict` 限定的指针修改。不能被除该指针以外的其他任何方式修改，无论是直接方式还是间接方式。该特定允许编译器采用特定的技术，编译器也可能选择忽略此限定符。
- `_Atomic` 采用 `_Atomic` 声明的对象是一个原子对象，数组不能是原子对象。注意，可特性是 C11 的可选特性。

一个对象可以同时使用 `const` 和 `volatile` ,如下例中 `ticks` 对象所示，它不能被程序本身修改，但可以被其他事件修改，例如时钟芯片的中断处理程序.

> 对指针类型来说，星号右边的类型限定符，限定的是指针本身。而在星号右边的类型限定符其限定的是指针所指向的对象类型。

### 声明和定义

可以不限次数的声明一个标识符，但是在其作用哉内，只有一个声明能作为定义。将具有外部链接的对象和函数声明放在头文件中，就很容易造成重复定义。

- 如果在声明函数时同时出现了函数块，则该函数的声明同时也是定义。
- 如果对象声明时给该对象分配内存，那么该对象的声明同时也是定义。具有初始化器的声明是定义。而且所有函数块内的声明都是定义（有 extern 存储类型修饰符的除外）
- 如果在函数外面声明一个对象，没有使用初始器，并且没有使用 `extern` 存储类型修饰符，那么这个定义就是临时性的 (tentative definition)

临时定义如果在对应翻译单元没有其他定义则仅仅是一个声明，此时编译器会为该临时定义加上值为 0 的初始化器。使其成为正式的定义。数组为初始化为有一个值为 0 的元素。


### 复杂声明符
当翻译一个复杂的声明符时，先从标识符开始，依次反复执行下列步骤。
1. 如果 `(` 或者 `[` 出现在标识符的右边那么翻译成成对的括号或者方括号。
2. 否则，如果是`*` 出现在左边，则翻译星号。

如下所示： `extern char *(*fTab[])(void);`

| 步骤                        | 翻译的符号               | 意义（从上而下阅读）                      |
| --------------------------- | ------------------------ | ----------------------------------------- |
| 1. 从标识符开始             | `fTab`                   | fTab 是...                                |
| 2. 右边有方括号             | `fTab[]`                 | 一个数组，其元素的类型是...               |
| 3. 左边有星号               | `(* fTab[])`             | 一个指针，指向...                         |
| 4. 右边有函数括号和参数列表 | `(* fTab[])(void)`       | 一个函数，该函数没有参数，返回值类型是... |
| 5. 左边有星号               | `*(* fTab[])(void)`      | 一个指针，指针类型为...                   |
| 6. 没有星号，括号读名称类型 | `char *(* fTab[])(void)` | char                                      |

`* fTab[]` 外的括号是必需的。如果没有括号 `fTab` 就会被声明为数组，其元素是函数，这样的声明是不可能的。

另一个示例：

`float (*func())[3][10];`
> 标识符func是...一个函数，它的返回值类型是...是一个指针,指向...一个具有3个元素的数组，元素类型为...10个元素的数组，元素类型为...float

**再次提醒** `* func()` 外面的括号是必需的，因为如果没有括号，该波函数会被声明为返回一个数组，而数组不可能是函数返回值类型。

声明符中 `()` 、`[]` 和 `*`的含义。

-  `()` 返回值类型为...的函数
-  `[]` 元素类型为...的数组
-  `*` 指向...类型的指针

在声明符中这些符号的优先级和结合律，与它们在表达式中的相同，而且类似在表达式中，可以使用括号改变被翻译的顺序。
注意如下类型定义的意义。

```c
int *abc[10]; // 一个具有10个元素的数组，这些元素的类型是指向int的指针。
int (*abc)[10]; // 一个指针,指向有10个int的元素的数组。
```

## 类型名称
如果想使用类型转换运算符把一个值显式地从一个类型转换为另一个类型，必须通过类型名称指定新的类型。
示例： `(char *)ptr` 表达式中， `char *` 读作：“char 指针”或 “指向char的指针”, 当把类型名称作为`sizeof` 的操作数时，它的出现方式也相同.
对于复杂的类型名称，先从第一组圆括号或方括号开始，一直翻译到最后一个星号右边。
例如：
1. `double (*)()` 表示 “指向函数的指针” 类型，该函数返回值为 double, 没有指定函数的参数和数量。

## typedef 声明
typedef 声明以关键字`typedef` 开头，后面接着普通对象或者函数的声明语法。
但是不能有存储类型或 `_Alignas` 限定符，以及不能有初始化器。

下面是 C 标准库中 `qsort`
```c
void qsort( void *ptr, size_t count, size_t size,
            int (*comp)(const void *, const void *) );
```
通过下面 `typedef`定义 CmpFn` 表示 `int (const void *,const void *)` 函数类型。 
`typedef int CmpFn(const void *, const void *);`
可以简化原函数的参数声明。

```c
void qsort(void *ptr,size_t count,size_t size,CmpFun *compare);
```


## `_Static_assert` 声明
`_Static_assert` 可以理解为一个编译期的静态断言。具有如下语法：
`_Static_assert(expression,message)`
