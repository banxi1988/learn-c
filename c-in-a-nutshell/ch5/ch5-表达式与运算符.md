# 表达式与运算符

## 表达式

### 泛型选择

泛型选择是 C11 新增加的特性。它可以编译时根据一个表达式的类型，从列表中选择一个表达式。
这种机制允许 C 程序员编写泛型宏。

基本语法如下:

```
_Generic ( controlling-expression , association-list )
association-list ->
  type-name : expression
  default : expression
```

列表没有兼容类型且没有默认类型会导致编译错误。

### 左值 （lvalue）

左值之所以叫做左值。
一个说法是因为它可以出现在赋值运算符的左边 (Left)
另一个说法是 `l` 表示 `locator` 定位器的意思，因为一个 lvalue 总是指明内存中的一个位置。

其他表达式（那些表示一个值但是不指明一个对象的），被类似的称之为右值。右值是可以出现在赋值运算的右边而不是左边的表达式，例如，常量和算术表达式。

1. 从一个左值中必定可以解析出对应对象的地址，除非该对象是位字段(bit-field)或者被声明为寄存器存储类。
2. 生成左值的运算符包括下标运算符(subscript operator)`[]`或间接运算符(indirection operator)`*`.如下表所示。

假充 array 已经被声明为数组，ptr 被声明为指针变量。

| 表达式      | 是左值吗？                                   |
| ----------- | -------------------------------------------- |
| `array[1]`  | 是，一个元素是一个具有位置的对象             |
| `&array[1]` | 否，此对象的位置，并非一个具有位置的对象     |
| `ptr`       | 是，此指针变量是一个具有位置的对象           |
| `*ptr`      | 是，此指针所指的地方是一个具有位置的对象     |
| `ptr+1`     | 否，此加法产生一个新的地址值，但不是一个对象 |
| `*ptr+1`    | 否，此加法产生一个新的算术值，但不是一个对象 |


### 副作用和序列点

副作用：计算一个表达式除了生成一个值之外还导致了执行环境的变化 ，这样的变化就叫做副作用。
序列点：在程序的执行过程中，有一些确定的点，在这些确定的点上，一个给定的表达式的所有副作用都会完成,而下一个表达式的副作用尚未发生。

**注意：** 不在两个连续的序列点之间多次修改任何的对象。如下示例：

```c
int i = 1; // OK
i = i++; // 错误，两次修改i 的值，运行结果不确定。
f() + g(); // C 语言并没有规定 f() 会在 g() 之前执行。
array[i] = array[++i];// 错误，运行结果不确定。
array[i] = array[i + 1]; ++i; // OK，有一个序列点将修改操作分开。
```

一些重要的序列点：
1. 当函数被调用时，在函数所有的实参被计算之后，在执行权传递到函数内的语句之前 。
2. 在表达式的末端，并且该表达式不是一个更大的表达式的一部分，这种完整表达式，包括表达式语句在内的表达式，for 语句内的3个控制表达式，if或while语句的条件表达式，return 语句表达式，以及初始化器。
3. 在下列运算符的第一个操作数被计算完之后:`&&`、`||`、`?:`、`,`