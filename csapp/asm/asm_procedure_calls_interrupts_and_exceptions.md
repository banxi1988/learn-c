# 过程 (Procedure)

在不同的语言中过程的表现形式不一样,有`function`,`method`,`subroutine`,`handler`.
不管形式是什么?都需要实现以下三个方面的处理.
以 `main` 函数调用 `add` 函数为例.

1. **传递控制** 在进入函数 `add`时,程序计数器必须被设置为`add`代码的起始地址. 然后在返回时要把程序器设置为`main`中调用 `add` 之后的那条指令的地址.
2. **传递数据** `main` 能够向 `add` 提供一个或多个参数,`add` 能够向 `main` 返回一个值.
3. **分配和释放内存** 在开始时,`add` 可能需要为局部变量分配空间,而在返回前又需要释放这些存储空间.

## 运行栈

运行时栈可以看作是内存地址的一个数组.有后进先出的特点. 在 X86-64 架构中是从高地址到低地址向下增长.

`%rsp` 用作栈指向指向栈顶的最后一个元素.
`pushq` 用于将数据压入栈. 同时减少 `%rsp` 指针的值.
`popq` 用于将栈顶数据弹出. 同时增加 `%rsp`指针的值.

下面示例中,是从第 7 个参数开始的,如果少于 7 个参数,可以通过寄存器传递.

| 栈内存地址 | 内存内容     | 说明              |
| ---------- | ------------ | ----------------- |
| N + 24     | 参数 8       | 如果有参数 8 的话 |
| N + 16     | 参数 7       | 如果有参数 7 的话 |
| N + 8      | 返回地址     | %rbp 指向此地址   |
| N ~ N+k    | 保存的寄存器 |
| N+k ~ N+m  | 局部变量     |
| N+m ~ N+n  | 参数构造区   |

其中 `%rsp` 指向栈顶.

继续以 `main` 调用 `add` 为例.
当 `main` 调用 `add` 时需要把返回地址压入栈中.指明当 `add` 返回时要从 `main` 的哪个位置继续执行.
一般我们把这个返回地址也当作`main` 栈帧的一部分.因为它是与 `main` 有关的状态.
大部分的过程的栈帧的大小都是确定的,过程的开始就分配好了.

## 转移控制

在 X86-64 中 一般使用 `call` 和 `ret` 作为转移控制指令. (另外一对是 `enter` 和 `leave`)

| 指令           | 描述              |
| -------------- | ----------------- |
| call Label     | 过程调用,直接调用 |
| call \*Operand | 过程调用,间接调用 |
| ret            | 从过程调用中返回  |

## 数据传送

| 操作数大小 | 参数 1 | 参数 2 | 参数 3 | 参数 4 | 参数 5 | 参数 6 |
| ---------- | ------ | ------ | ------ | ------ | ------ | ------ |
| 64         | %rdi   | %rsi   | %rdx   | %rcx   | %r8    | %r9    |
| 32         | %edi   | %esi   | %edx   | %ecx   | %r8d   | %r9d   |
| 16         | %di    | %si    | %dx    | %cx    | %r8w   | %r9w   |
| 8          | %dil   | %sil   | %dl    | %cl    | %r8b   | %r9b   |

如果一个函数有超过 6 个参数,超出的部分就需要通过栈来传递了.

## 栈上的局部存储

有时局部数据必须放在内存中.如:

1. 寄存器不够用了.
2. 对于一个局部变量使用取地址运算符`&`,因此必须能够为它产生一个地址.
3. 某些局部变量是数组或结构,因此必须能够通过数组或结构引用被访问到.

## 寄存器中的局部存储空间

寄存器组这一资源是被所有过程所共享的.
需要确保`main`调用 `add` 时,`add` 不会覆盖`main` 稍后会使用的寄存器.
x86-64 为此制定了一组统一的寄存器使用惯例.

1. `%rbx`,`%rbp` 和 `%r12~%r15` 被划分为被调用者保存寄存器. 比如当 `main` 调用 `add` 时,`add`必须保存这些寄存器的值,保证它们的值在`add`返回时与`add`被调用时是一样的.
2. 其他寄存器,除 `%rbp` 之外都归为调用者保存寄存器.意味着任何函数都能修改它们. 也就是说在 `main` 调用 `add` 之间,保存这些寄存器的值的责任大于`main`,`add`可以随便使用.
